#Q16. Write a function aliquot_sum(n) that returns the sum of all proper divisors of n (divisors less than n).

#CODE:
import time
import sys

var=1

start_time=time.time()

def aliquot_sum(n):
    1 is 0.
    if n <= 0:
        return 0

    # Initialize the sum of divisors
    total_sum = 0
    
    i = 1
    
    while i < n:
        if n % i == 0:
            total_sum = total_sum + i
        
        i = i + 1
        
    return total_sum

n=int(input("Enter the number:"))
print(aliquot_sum(n))
end_time=time.time()
execution_time=end_time-start_time
print("Execution time:", execution_time)
print(sys.getsizeof(var))

#OUTPUT:
Enter the number:56
64
Execution time: 0.9809694290161133
28



#Q17. Write a function are_amicable(a, b) that checks if two numbers are amicable (sum of proper divisors of a equals b and vice versa).

#CODE:
import time
import sys

var=1

start_time=time.time()
def aliquot_sum(n):
    if n <= 0:
        return 0

    total_sum = 0
    i = 1 # Start checking for divisors from 1

    while i < n:
        # Check if 'i' is a divisor of 'n' using the modulo operator
        if n % i == 0:
            # Add it to the total sum
            total_sum = total_sum + i

        i = i + 1

    return total_sum

def are_amicable(a, b):
    
    if a == b:
        return False
    
    if a <= 0 or b <= 0:
        return False
        
    sum_a = aliquot_sum(a)
    
    sum_b = aliquot_sum(b)
    
    is_amicable = (sum_a == b) and (sum_b == a)
    
    return is_amicable

n=int(input("Enter the number:"))
a=int(input("Enter the first0 number:"))
b=int(input("Enter the other number:"))
print(are_amicable(a, b))
end_time=time.time()
execution_time=end_time-start_time
print("Execution time:", execution_time)
print(sys.getsizeof(var))

#OUTPUT
Enter the number:5
Enter the first number:65
Enter the other number:2
False
Execution time: 2.0465891361236572
28



#Q18. Write a function multiplicative_persistence(n) that counts how many steps  until a number's digits multiply to a single digit.

#CODE:
import time
import sys

var=1
start_time=time.time()
def multiplicative_persistence(n):
    
    if n < 10:
        return 0

    persistence_count = 0
    
    while n >= 10:
        persistence_count = persistence_count + 1
        
        next_n = 1
        
        current_num = n
        
        while current_num > 0:
            digit = current_num % 10
            
            next_n = next_n * digit
            
            current_num = current_num // 10
            
        n = next_n
        
    return persistence_count


n=int(input("Enter the number:"))
print(multiplicative_persistence(n))
end_time=time.time()
execution_time=end_time-start_time
print("Execution time:", execution_time)
print(sys.getsizeof(var))

#OUTPUT:
Enter the number:56
2
Execution time: 4.965705633163452
28



#Q19. Write a function is_highly_composite(n) that checks if a number has more divisors than any smaller number.

#CODE:
import time
import sys

var=1

start_time=time.time()
def count_divisors(n):
    
    if n <= 0:
        return 0
    
    if n == 1:
        return 1

    divisor_count = 0
    
    while i <= n:
        if n % i == 0:
            divisor_count = divisor_count + 1
        
        i = i + 1
        
    return divisor_count

def is_highly_composite(n):
    
    if n <= 0:
        return False
    
    if n == 1:
        return True
        
    n_divisors = count_divisors(n)
    
    i = 1
    is_hcn = True
    
    while i < n:
        i_divisors = count_divisors(i)
        
        if i_divisors >= n_divisors:
            is_hcn = False
            break
            
        i = i + 1
        
    return is_hcn

n=int(input("Enter the number:"))
print(is_highly_composite(n))
end_time=time.time()
execution_time=end_time-start_time
print("Execution time:", execution_time)
print(sys.getsizeof(var))

#OUTPUT:
Enter the number:56
False
Execution time: 0.911412239074707
28



#Q20. Write a function for Modular Exponentiation mod_exp(base, exponent, modulus) that efficiently calculates (baseexponent) % modulus.

#CODE:
import time
import sys

var=1

start_time=time.time()

def mod_exp(base, exponent, modulus):
    
    
    if modulus == 1:
        return 0

    res = 1
    
    base = base % modulus
    
    current_exponent = exponent
    
    while current_exponent > 0:
        
        if current_exponent % 2 == 1:
            res = (res * base) % modulus
        
        base = (base * base) % modulus
        
        current_exponent = current_exponent // 2
        
    return res

base=int(input("Enter the base:"))
exponent=int(input("Enter the exponent:"))
modulus=int(input("Enter the modulus:"))
print(mod_exp(base, exponent, modulus))
end_time=time.time()
execution_time=end_time-start_time
print("Execution time:", execution_time)
print(sys.getsizeof(var))

#OUTPUT:
Enter the base:5
Enter the exponent:9
Enter the modulus:8
5
Execution time: 5.561293840408325
28
